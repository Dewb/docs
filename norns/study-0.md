---
layout: default
nav_exclude: true
permalink: /norns/study-0/
---

<div class="vid"><iframe src="https://player.vimeo.com/video/503167191?color=ffffff&title=0&byline=0&portrait=0" width="860" height="484" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>

# first light
{: .no_toc }

Before study, learning to see.

<details open markdown="block">
  <summary>
    sections
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

## who am i

We have ideas about what it means to be a musician and what it means to be a programmer, and these ideas shape how we approach instruments and code.

norns is a platform for customizing and creating sound instruments with code.

While norns can be used to craft ambitious sonic toolkits, it can also be used to create small compositional moments.

This study aims to show the musician the power of utilizing and editing a few lines of code, and to show the programmer that sound can be explored playfully.

## what will we use

norns is comprised of three primary layers:

1. [SuperCollider](https://supercollider.github.io), which is where the qualities of a norns synth engine are defined. This can be a monophonic sine oscillator, a polyphonic supersaw, a sample player with dozens of slots, a 12-voice drum synth, etc.
2. [Lua](https://www.lua.org/about.html), which is where *control* and *interactions* are defined:
  - Lua can be used to define how a performer interacts with a SuperCollider engine, eg. changing synthesis parameters
  - Lua can also be used to parse MIDI to/from external gear, eg. building a MIDI sequencer which doesn't have a specific SuperCollider target
  - Lua also defines + interprets the norns hardware, eg. what gets printed to the screen and what should happen when key 3 is pressed or encoder 2 is turned
3. [softcut](/docs/norns/softcut), which is a multi-voice, variable-speed sample playback and recording system built into the norns environment, controlled by Lua. This is separate from (yet complementary to) what the SuperCollider layer provides. A script can choose to ignore SuperCollier entirely and rely solely on softcut to manipulate live or prerecorded audio. Alternatively, a script can route audio generated by SuperCollider *into* softcut, to resample and mangle the synth they're controlling via Lua.

Depending on your interests and goals, you may find yourself compelled toward one facet of the norns environment more than another. For the purposes of this study, we'll gently introduce each layer by showing you a few fun and immediate ways to leverage small bits of code to make music. Don't worry if you feel like you don't fully understand every coding concept presented -- subsequent [studies](/docs/norns/studies) go into greater detail.

## a short journey

To start, let's get norns connected to [wifi](../wifi-files) and open [maiden](../maiden). In the [maiden project manager](../maiden/#project-manager), search for _firstlight_ in the `base` collection at the top of the `available` scripts, install it, then run it on your norns.

Sit, listen.

What you're hearing:

- a wind chime synth (a SuperCollider engine named `PolyPerc`)
- you can toggle the wind chime on/off with K3 (an interaction defined in Lua)
- the wind chime is running through a simple delay effect made with a single softcut voice
- the delay length is being sequenced by a mechanism you can toggle on/off with K2 (another interaction defined in Lua)

Also, you can also play sound into the audio input.

**Let's toggle off the wind chime synth (press K3), toggle off the softcut delay length sequencer (K2), and play with some code.**

## the code is alive

In this section, we'll execute small chunks of Lua code in realtime to control different elements of the _firstlight_ script. The goal is to introduce a few fundamental commands and make typing musical ideas feel approachable and fun!

### manually playing the engine

Click on the `>>` bar at the bottom of maiden. This is the **matron REPL**, where we'll enter commands and press ENTER to *execute* them. Throughout this document, anywhere you see `>>`, that lets you know the code should be executed in the matron REPL (don't type `>>` in the actual code you execute, though!).

**We encourage you to type every command -- copying and pasting will not be as memorable / meaningful.**

The script we're running can manipulated in real time, and that's what we'll do now. Try executing this in the matron REPL:

```lua
>> engine.hz(700)
```

This Lua chunk tells the SuperCollider engine to play a 700hz tone, which will feed into the softcut delay. Try replacing `700` with different numbers, or try multiplying `700` by different values. If you enjoy exploring pitch relationships like this, you may also enjoy reading about [music and math](https://en.wikipedia.org/wiki/Music_and_mathematics).

Since `PolyPerc` (_firstlight_'s SuperCollider engine) is polyphonic, we can play many tones at once. To execute many commands in a single chunk in Lua, use semicolons:

```lua
>> engine.hz(700); engine.hz(700/2); engine.hz(700*2.4)
```

Try executing a few chords of your own devising!

`engine.hz` is just one of the commands this SuperCollider engine will respond to. This means the SuperCollider code actually contains a definition for the `hz` command, which is written to accept a single argument (`700` or `432` or `641.2401`) as the pitch of the tone SuperCollider will produce.

To get a full list of the commands and their expected arguments, execute:

```lua
>> engine.list_commands()
```

which will return:

```bash
___ engine commands ___
amp		f
cutoff		f
gain		f
hz		f
pan		f
pw		f
release		f
```

This list lets us know that we can append any of those commands to `engine.` and change the synth, as long as we supply the expected argument, `f`, which means a 'floating-point number'. In Lua, all numbers are floating-point, so `3` and `3.0` are the same.

To make some changes, turn on the wind chimes (K3) and try executing these lines:

```lua
>> engine.pw(0.2)
>> engine.cutoff(300)
>> engine.release(2.1)
```

Next, try some of your own numbers for each of these commands' arguments!

### controlling softcut

As mentioned earlier in this doc, `softcut` is a 6-voice digital tape system built into norns. _firstlight_ uses a single voice of softcut to create the delay effect (specifically, voice 1) so let's turn the wind chimes back on (press K3) and manipulate it a bit. 

If you haven't already turned off the softcut delay length sequencer (K2), please do -- it'll help make the effect of the following exercises clearer.

Turn the delay off (by reducing voice 1's level to 0):

```lua
>> softcut.level(1, 0)
```

Turn the delay on (by raising voice 1's level to 1):

```lua
>> softcut.level(1, 1)
```

Set the delay to quarter-volume:

```lua
>> softcut.level(1, 0.25)
```

In case it's opaque, the general pattern we're following is:

```lua
softcut.command(voice_id, command_value)
```
(You don't *need* a space the comma, it's just a bit more readable for learning.)

The full range of softcut commands can be found in the [softcut API](/docs/norns/api/modules/softcut.html). Let's try some of the other commands!

The following command changes the feedback level to 95%:

```lua
>> softcut.pre_level(1, 0.95)
```

**Careful, setting `softcut.pre_level` to values greater than 1.0 ( = 100%) can eventually create very loud sounds!**

Like a tape machine, we can change the speed of individual softcut voices to be faster or slower. In our current softcut-as-delay configuration, changing the rate means audio recorded at the old rate will be played back faster or slower -- but as you continue to feed in audio, you'll eventually notice that pitch remains the same while overall _time_ changes. This is because the playhead and record heads are moving faster or slower together.

To hear what we mean, try executing these commands one at a time:

```lua
>> softcut.rate(1, 2.0)
>> softcut.rate(1, 1.0)
>> softcut.rate(1, 0.5)
```

You'll notice there's a bit of a pitch ramp when you change rate -- this is determined by the [`rate_slew_time`](/docs/norns/api/modules/softcut.html#rate_slew_time) command. _firstlight_ starts with a default value of 1 second.

Try a few new values and see if you like something less or more dramatic:

```lua
>> softcut.rate_slew_time(1, 0)
>> softcut.rate_slew_time(1, 5.42)
>> softcut.rate_slew_time(1, 0.23)
```

### a few more chunks

Let's turn on the softcut sequencer *without* pressing the physical K2 button:

```lua
>> sequence = true
```

The softcut delay length sequencer is synchronized to the global clock. You can change the clock settings via the PARAMS menu, but you can also act upon the clock this way:

```lua
>> params:set('clock_tempo',50)
```

The script has few other simple variables that can be changed on the fly. What happens when you execute each of the following commands?

```lua
>> chimes = false
>> length = 16
>> numbers[1] = 13
```

<details closed markdown="block">
  <summary>
    *answers*
  </summary>
  {: .text-delta }
- `chimes = false` turns off the wind chimes
- `length = 16` increases the length of the softcut delay length sequencer to sixteen steps
- `numbers[1] = 13` increases the size of the first delay sequencer column, which extends the length of the delay loop
{:toc}
</details>


## make it so

Entering commands as we did above changes the running state of the script, but the system doesn't remember these changes if you restart. So, let's edit the actual script so we can load our customized version.

You will want to make a copy of the original file, which you can do in maiden:

- navigate to the `code > firstlight` folder in the file viewer (don't see the file viewer? press the piece of paper on maiden's left menu bar)
- select the `firstlight.lua` file
- press the `duplicate file` icon (the two pieces of paper) in the file viewer's top menu bar
- select the newly-created `firstlight1.lua` file
- press the `rename file/folder` icon (the pencil) to rename it
- select your newly-renamed file and press the `save script` icon (the floppy disk) on the far-right menu bar to save your new file

The script has a few built-in places where home-editing is effective, marked by this sweet lil' friend:  
<kbd>--[[ 0_0 ]]--</kbd>

Let's change a few default values to customize:

- synth sound
- delay feedback
- chime notes

To change the startup synth parameters, see [line 77](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L77-L80):

```lua
-- configure the synth --[[ 0_0 ]]--
engine.release(1)
engine.pw(0.5)
engine.cutoff(1000)
```

**If changes result in an error, don't worry! The REPL will tell you which lines are troublesome so you can resolve errors and run the script again.**

Try changing the arguments (the numbers between parenthesis), save the file, then re-launch the script using the PLAY arrow in maiden or using the menu on the hardware.

To change the delay feedback, see [line 100](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L100):

```lua
softcut.pre_level(1, 0.85) --[[ 0_0 ]]--
```

Try changing the second argument, save the file, then re-launch the script using the PLAY arrow in maiden or using the menu on the hardware.

To change the chime notes, see [line 61](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L61-L62):

```lua
--[[ 0_0 ]]--
notes = {400,451,525,555}
```

`notes` is a [table](https://www.lua.org/pil/2.5.html) of notes. Tables can contain many things, but in this case the table is a list of numbers separated by commas and enclosed by braces. The notes are frequencies, just like we called with `engine.hz(700)`.

Try changing the values of the `notes` table -- the chime player (the enclosing [`wind`](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L58) function) can handle different table lengths ([greater than zero](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L63)), so feel free to add additional notes!

## now differently

Now that we've successfully changed some of the default values, let's make some small changes to alter how the script actually works.

### clock by hand

Instead of having the softcut delay length sequencer run on a clock, let's have it step forward every time we push K2.

First, we'll need to make sure the sequence doesn't autostart when the script is loaded. We can change this default on [line 32](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L32) from:

```lua
sequence = true
```
to:

```lua
sequence = false
```

Now, when the script starts and the [system clock ticks](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L36-L45), the `step()` function will not be run!

Let's try executing `step()` in the matron REPL, to confirm that it will advance the sequencer:

```lua
>> step()
```

**please note: If you need to re-execute something you just executed in the matron REPL, press the up arrow on your keyboard to recall it and press ENTER to re-execute.**

Now, let's assign the execution of `step()` to K2.

As mentioned in the intro, all norns scripts contain definitions for how the hardware should behave. try searching your version of _firstlight_ to find where the `key` function is defined ([hint](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L144-L153)).

To change what happens when K2 gets pressed, we'll edit [line 151](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L151) by commenting it out by typing two dashes in front of the line and adding our `step` command line below:

```lua
--[[ 0_0 ]]--
-- sequence = not sequence
step()
```

**please note: Two dashes in front of a line of code will comment-out the line and keep it from being executed.**

We want to comment-out `sequence = not sequence` because we don't want a K2 press to toggle the sequencer on/off -- instead, we want it to manually step the sequence.

Save and re-run. Now, pressing K2 advances the softcut delay length sequencer!

### play a random pitch

Instead of relying on our wind chime mechanism, let's employ K3 to play a random tone through our synth engine.

First, we'll disable the chimes by changing [line 33](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L33) to:

```lua
chimes = false
```

We'll revisit the [`key` function](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L145-L153) to reassign K3's action. Comment-out [line 148](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L148) to unassign the chimes toggle action from K3. After this line, add a command to play a random frequency between 100 and 600:

```lua
-- chimes = not chimes
engine.hz(math.random(100,600))
```
We want to comment-out `chimes = not chimes` because we don't want a K3 press to toggle the chimes on/off -- instead, we want it to play our SuperCollider engine at a random pitch.

Save and re-run the script to try it out. Every time you press K3, you should hear a new tone!

## advanced mods

these modifications increase in complexity, so make sure you feel comfortable with the core concepts of each before moving ahead.

### randomly select a pitch

Let's make a change so that K3 plays a random selection of discrete pitches from a table, instead of randomly selecting pitches across a range.

Replace the `engine.hz` line from the previous exercise with:

```lua
basket = {80,201,400,555,606}
engine.hz(basket[math.random(#basket)])
```

`basket` can be any length, so feel free to add as many frequencies as you'd like, separating them by commas.

Breaking `engine.hz(basket[math.random(#basket)])` down a bit, from the inside-out:

- `#basket` will return the number of values in the `basket`
- `math.random(x)` generates a random number from `1` to `x` (in this case, 1 to the number of values in the `basket`)
- `basket[x]` gets the `x`th element of the table (in our example, `basket[1]` would return `80`)
- `80` gets passed to `engine.hz()` as an argument and the note gets played at 80hz!

#### curly braces, brackets, and parentheses

At this point, you might be wondering why we're using so many different symbols in our code. Simply put, it depends on a variable's data type (eg. is it a table or a function?) and what action we're performing (eg. are we defining a table, or are we querying a specific value within the table, or are we executing a function with specific arguments?).

Here are a few helpful bits to know as you continue to experiment with the techniques covered in this study so far:

Create a table (curly braces):

```lua
>> my_table = {1,3,8,3,5,19,-42,0}
```

Query the table's length (`#`):

```lua
>> #my_table
8 -- this is what the REPL will return
```

Query the value of the table at a specific index (square brackets):

```lua
>> my_table[6]
19 -- this is what the REPL will return
```

Replace the value of the table at a specific index (square brackets):

```lua
>> my_table[8] = 900
```

Print the table using a function (parentheses):

```lua
>> tab.print(my_table)
-- this is what the REPL will return:
1	1
2	3
3	8
4	3
5	5
6	19
7	-42
8	900
```

Remove the third value of the table (parentheses):

```lua
>> table.remove(my_table, 3)
8 -- this is what the REPL will return
```

Generate a random value using a function (parentheses):

```lua
>> math.random()
>> math.random(9,12)
>> math.random(30)/10
```

Generate a random value and use it to replace the value of the table at a specific index (mixed):

```lua
>> my_table[2] = math.random(7)
```

Query the value of the table at a random index (mixed):

```lua
>> my_table[math.random(#table)]
```

### even strum

Instead of a windy chime with variation, let's have the wind make a regular strum.

**But first, a brief detour.**

Try executing the following in matron's REPL:

```lua
>> t = {1,2,3,4,5,6}
>> table.remove(t,1); tab.print(t)
>> table.remove(t,1); tab.print(t)
>> table.remove(t,1); tab.print(t)
>> table.remove(t,1); tab.print(t)
>> table.remove(t,1); tab.print(t)
>> table.remove(t,1); tab.print(t)
```

Each time we execute `table.remove(t,1)`, the `t` table's current first element is sequentially removed and the table's values shift their index.

Let's try randomly removing values from the `t` table by using the number of entries in the `t` table to generate a random number for `table.remove`:

```lua
>> t = {1,2,3,4,5,6}
>> table.remove(t,math.random(#t)); tab.print(t)
>> table.remove(t,math.random(#t)); tab.print(t)
>> table.remove(t,math.random(#t)); tab.print(t)
>> table.remove(t,math.random(#t)); tab.print(t)
>> table.remove(t,math.random(#t)); tab.print(t)
>> table.remove(t,math.random(#t)); tab.print(t)
```

What's cool about `table.remove` is that we can actually *do* stuff with the removed number:

```lua
>> t = {100,200,300,400,500,600}
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
>> engine.hz(table.remove(t,math.random(#t))); tab.print(t)
```

With that in mind, let's take a look at the `wind` section starting at [line 55](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L55-L71). In particular, the three line starting at [line 64](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L64) should contain something pretty familiar:

```lua
if math.random() > 0.2 then
  engine.hz(table.remove(notes,math.random(#notes)))
end
```

What this bit does:

- make a random number between 0.0 and 1.0 (which `math.random()` with no arguments returns)
- if it is greater than 0.2 then...
- get a random value from the `notes` table and remove it
- play the removed note

This creates the nice random scattered effect and creates uneven timing, with no single note played twice.

Let's comment out these three lines (with `--` in front) and make it more regular:

```lua
engine.hz(table.remove(notes,1))
```

This simpler line just gets the first element of the table and removes it, so the notes get played in order.

Try changing the strum speed by altering [line 67](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L67):

```lua
clock.sleep(0.05)
```

You can further modify this line by adding a bit of randomization. To have a random strum every 3-9 seconds:

```lua
clock.sleep(math.random(3,9))
```

### sequence weirder

The sequencer step values can be used for any number of things. Instead of modulating the softcut delay length, let's modulate the delay rate, which will re-pitch the delay line wildly.

See [line 52](https://github.com/monome/firstlight/blob/e67ee2f104bfc60f5053b94c3bd9c80f50efd867/firstlight.lua#L52):

```lua
softcut.loop_end(1,numbers[pos]/8)
```

<dl>
  <dt><b>numbers</b></dt>
  <dd>a table (line 25) that gets updated with the knob interface. it's the sequencer data, which is basically up to 16 steps of values 1-8</dd>
  <dt><b>pos</b></dt>
  <dd>the playback position. line 50 advances the position by adding 1 and maybe wrapping back to the start. (hint: try changing <i>pos+1</i> to <i>pos-1</i> to make it run backwards!)</dd>
  <dt><b>loop_end</b></dt>
  <dd> we're dividing the step value by 8, so we'll set <i>loop_end</i> setting to between 1/8 and 1.0 (= 8/8)</dd>
</dl>

let's comment out this line and modulate `rate` instead:

```lua
--softcut.loop_end(1,numbers[pos]/8)
softcut.rate(1,numbers[pos]/8)
```

Save and try it out!

Since the rate jumps are very large the result is substantial. Let's try making it more subtle:

```lua
softcut.rate(1,1+(numbers[pos]/64))
```

This confines the numbers to a smaller range for a subtler effect. Perhaps we'd like to try something with multiples:

```lua
rates = {-1.0,-0.5,0.25,0.5,1.0,1.5,2.0,3.0}
softcut.rate(1,rates[numbers[pos]])
```

We've made a table `rates` which has 8 elements, letting us map the range of each step. This set of numbers contains a bunch of octaves which can create sparkly-delays. It also contains negative numbers which make for some nice reversals.

Try setting `softcut.rate_slew_time(1,0)` down around line 98, which will make rate changes instantaneous rather than sliding.

## from here

suggested exercises:

- randomize `x` for `engine.cutoff(x)` on each wind chime ([solution](/docs/norns/firstlight-further/engine-cutoff))
- make K2 set delay feedback (`softcut.pre_level(1,x)`) to a random value between `0.2` and `0.99` ([solution](/docs/norns/firstlight-further/delay-feedback))
- re-route the softcut sequencer to send notes to the SuperCollider engine. consider [just intonation](https://en.wikipedia.org/wiki/Just_intonation) for your pitch definitions.
- have K3 cycle delay speed with a table `{-1.0,0.5,1.0}`

and then on to [study 1: many tomorrows](../study-1) for a more in-depth scripting journey.

## resources

- [script reference](../reference) - lists of norns API commands and how to use them
- [firstlight walkthrough](https://vimeo.com/515473339) - a recorded livestream of a _firstlight_ study walkthrough

## continued
{: .no_toc }

- part 0: [first light](../study-0/) //  variables, simple maths, keys + encoders
- part 1: many tomorrows
- part 2: [patterning](../study-2/) // screen drawing, for/while loops, tables
- part 3: [spacetime](../study-3/) // functions, parameters, time
- part 4: [physical](../study-4/) // grids + midi
- part 5: [streams](../study-5/) // system polls, osc, file storage

## community
{: .no_toc }

ask questions and share what you're making at [llllllll.co](https://llllllll.co/t/norns-studies/14109)

edits to this study welcome, see [monome/docs](http://github.com/monome/docs)
