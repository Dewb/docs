---
layout: default
nav_exclude: true
permalink: /norns/study-0/

---

<div class="vid"><iframe src="https://player.vimeo.com/video/503167191?color=ffffff&title=0&byline=0&portrait=0" width="860" height="484" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>

# first light
{: .no_toc }

before study, learning to see.

<details open markdown="block">
  <summary>
    sections
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

## who am i

we have ideas about what it means to be a musician and what it means to be a programmer, and these ideas shape how we approach instruments and code.

norns is a platform for customizing and creating sound instruments with code.

while norns can be used to craft ambitious sonic toolkits, it can also be used to create small compositional moments.

this study aims to show the musician the power of utilizing and editing a few lines of code, and to show the programmer that sound can be explored playfully.

## what will we use

norns is comprised of three primary layers:

1. [SuperCollider](https://supercollider.github.io), which is where the qualities of a norns synth engine are defined. this can be a monophonic sine oscillator, a polyphonic supersaw, a sample player with dozens of slots, a 12-voice drum synth, etc.
2. [Lua](https://www.lua.org/about.html), which is where *control* and *interactions* are defined:
  - Lua can be used to define how a performer interacts with a SuperCollider engine, eg. changing synthesis parameters
  - Lua can also be used to parse MIDI to/from external gear, eg. building a MIDI sequencer which doesn't have a specific SuperCollider target
  - Lua also defines + interprets the norns hardware, eg. what gets printed to the screen and what should happen when key 3 is pressed or encoder 2 is turned
3. [softcut](/docs/norns/softcut), which is a multi-voice, variable-speed sample playback and recording system built into the norns environment, controlled by Lua. this is separate from (yet complementary to) what the SuperCollider layer provides. a script can choose to ignore SuperCollier entirely and rely solely on softcut to manipulate live or prerecorded audio. or a script can route audio generated by SuperCollider *into* softcut, to resample and mangle the synth they're controlling via Lua.

depending on your interests and goals, you may find yourself compelled toward one facet of the norns environment more than another. for the purposes of this study, we'll gently introduce each layer by showing you a few fun and immediate ways to leverage small bits of code to make music.

## a short journey

to start, let's get norns connected to [wifi](../wifi-files) and open [maiden](../maiden). in the [maiden project manager](../maiden/#project-manager), search for _firstlight_ in the `base` collection at the top of the `available` scripts, install it, then run it on your norns.

sit, listen.

what you're hearing is a wind-chime synth (a SuperCollider engine named `PolyPerc`) which you can toggle on/off with K3 (an interaction defined in Lua), running through a simple delay effect (a softcut voice), which is sequenced by a mechanism you can toggle on/off with K2 (another interaction defined in Lua).

oh, right, you can also play sound into the audio input. pretty neat!

...

ok let's toggle off the windchimes (press K3), toggle off the softcut sequencer (K2), and play with some code.

## the code is alive

### manually playing the engine

click on the `>>` bar at the bottom of maiden. this is the **matron REPL**, where we'll enter commands and press ENTER to execute them. throughout this document, anywhere you see `>>`, that lets you know the code should be executed in the matron REPL (don't type `>>` in the actual code you execute, though!)
{: .label}

the script we're running can manipulated in real time, and that's what we'll do now. try executing this in the matron REPL:

```lua
>> engine.hz(700)
```

this Lua chunk tells the SuperCollider engine to play a 700hz tone, which will feed into the softcut delay. try replacing `700` with different numbers, or try multiplying `700` by different values. if you enjoy exploring pitch relationships like this, you may also enjoy reading about [music and math](https://en.wikipedia.org/wiki/Music_and_mathematics).

since `PolyPerc` (_firstlight_'s SuperCollider engine) is polyphonic, we can play many tones at once. to execute many commands in a single chunk in Lua, use semicolons:

```lua
>> engine.hz(700); engine.hz(700/2); engine.hz(700*2.4)
```

try executing a few chords of your own devising!

`engine.hz` is just one of the commands this SuperCollider engine will respond to. this means the SuperCollider code actually contains a definition for the `hz` command, which is written to accept a single argument (`700` or `432` or `641.2401`) as the pitch of the tone SuperCollider will produce.

to get a full list of the commands and their expected arguments, execute:

```lua
>> engine.list_commands()
```

which will return:

```bash
___ engine commands ___
amp	 		f
cutoff	 	f
gain	 	f
hz		 	f
pan	 		f
pw	 		f
release	 	f
```

this list lets us know that we can append any of those commands to `engine.` and as long as we supply the expected argument. to hear this, turn on the windchimes (K2) and try executing these lines:

```lua
>> engine.pw(0.2)
>> engine.cutoff(300)
>> engine.release(2.0)
```

next, try some unique values for each of these commands' arguments!

### controlling softcut

as mentioned earlier in this doc, `softcut` is a 6-voice digital tape system built into norns. _firstlight_ uses a single voice of softcut to create the delay effect (specifically, voice 1) so let's turn the windchimes back on (press K3) and manipulate it a bit. 

if you haven't already turned off the softcut sequencer (K2), please do -- it'll help make the effect of the following exercises clearer.

turn the delay off (by reducing voice 1's level to 0):

```lua
>> softcut.level(1,0)
```

turn the delay on (by raising voice 1's level to 1):

```lua
>> softcut.level(1,1)
```

to set the delay to quarter-volume:

```lua
>> softcut.level(1,0.25)
```

in case it's opaque, the general pattern we're following is:

```lua
softcut.command(voice_id, command_value)
```

the full range of softcut commands can be found in the [softcut API](/docs/norns/api/modules/softcut.hmtl). let's try some of the other commands!

the following command changes the feedback level to 95%:

```lua
>> softcut.pre_level(1,0.95)
```

careful, setting `softcut.pre_level` to values greater than 1.0 ( = 100%) can eventually create very loud sounds!
{: .label .label-red}

like a tape machine, we can change the speed of individual softcut voices to be faster or slower. in our current softcut-as-delay configuration, changing the rate means audio recorded at the old rate will be played back faster or slower -- but as you continue to feed in audio, you'll eventually notice that pitch remains the same while overall _time_ changes. this is because the playhead and record heads are moving faster or slower together.

to hear what we mean, try executing these commands one at a time:

```lua
>> softcut.rate(1,2.0)
>> softcut.rate(1,1.0)
>> softcut.rate(1,0.5)
```

you'll notice there's a bit of a pitch ramp when you change rate -- this is determined by the [`rate_slew_time`](/docs/norns/api/modules/softcut.html#rate_slew_time) command. _firstlight_ starts with a default value of 1 second. try a few new values and see if you like something less or more dramatic.

### a few more

let's turn on the softcut sequencer *without* pressing the physical K2 button:

```lua
>> sequence = true
```

the softcut sequencer is synchronized to the global clock. you can change the clock settings via the PARAMS menu, but you can also act upon the clock this way:

```lua
>> params:set('clock_tempo',50)
```

the script has few other simple variables that can be changed on the fly. what happens when you execute each of the following commands?

```lua
>> chimes = false
>> length = 16
>> numbers[1] = 0
```

## make it so

entering commands as we did above changes the running state of the script, but the system doesn't remember these changes if you restart. so, let's edit the actual script so we can load our customized version.

you will want to make a copy of the original file, which you can do in maiden:

- navigate to the `code > firstlight` folder in the file viewer (don't see the file viewer? press the piece of paper on maiden's left menu bar)
- select the `firstlight.lua` file
- press the `duplicate file` icon (the two pieces of paper) in the file viewer's top menu bar
- select the newly-created `firstlight1.lua` file
- press the `rename file/folder` icon (the pencil) to rename it
- select your newly-renamed file and press the `save script` icon (the floppy disk) on the far-right menu bar to save your new file

the script has a few built-in places where home-editing is effective, marked by this sweet lil' friend:  
<kbd>--[[ 0_0 ]]--</kbd>

let's change some defaults when the scripts starts:

- different synth sound
- more delay feedback
- different and more chime

see line 77:

```lua
--[[ 0_0 ]]--
engine.release(1)
engine.pw(0.5)
engine.cutoff(1000)
```

these are the synth parameters that get set at startup. try changing the numbers, save the file, then re-launch the script using the PLAY arrow in maiden or using the menu on the hardware.

line 100 sets the delay feedback:

```lua
softcut.pre_level(1, 0.85) --[[ 0_0 ]]--
```

line 62 is the table of notes. in this case the table is a list of numbers, separated by commas and enclosed by braces:

```lua
--[[ 0_0 ]]--
notes = {400,451,525,555}
```

the notes are frequencies, just like we called with `engine.hz(700)`. try changing the values of the table, and also adding additional notes. the chime player can handle different table lengths.

## now differently

now that we've successfully changed the defaults, let's do some small changes that alter how the script actually works.

### clock by hand

instead of having the sequencer run on a clock, let's have it step forward every time we push K2.

first, let's disable the sequence clock on line 32:

```lua
sequence = false
```

now, when the clock ticks, line 43 shows that the function `step()` will not be run. (by the way, we can type `step()` into the maiden REPL to advance the sequencer!)

let's edit what happens when K2 gets pressed, on line 151:

```lua
--[[ 0_0 ]]--
-- sequence = not sequence
step()
```

add two dashes to comment-out the sequence toggle, which deactivates this line of code. then add `step()`. save and re-run. now K2 advances the sequencer!

### play a random note

instead of chimes, let's have K3 play a random tone.

first, let's disable the chimes, on line 33:

```lua
chimes = false
```

on line 148 we disable the chimes toggle. after this line we add a command to play a random frequency between 100 and 600.

```lua
-- chimes = not chimes
engine.hz(math.random(100,600))
```

save at try it out.

let's make a change so that it plays notes from a table instead. erase the `engine.hz` line and do this instead:

```lua
basket = {80,201,400,555,606}
engine.hz(basket[math.random(#basket)])
```

`basket` can be any length: add more frequencies separated by commas. `math.random(x)` makes a random number from `1` to `x`. `basket[x]` gets the `x` element of the table, so `basket[1]` would be `80`. this gets passed to `engine.hz()` and the note gets played!

### even strum

instead of a windy chime with variation, let's have the wind make a regular strum. make sure line 33 is turned back on: `chimes = true`.

see line 64:

```lua
if math.random() > 0.2 then
  engine.hz(table.remove(notes,math.random(#notes)))
end
```

what this bit does:

- make a random number between 0.0 and 1.0
- if it is less than 0.2 then
- get a random value from the `note` table and remove it
- play this note

this creates the nice random scattered effect and creates uneven timing, with no single note played twice.

let's comment out these three lines (with `--` in front) and make it more regular:

```lua
engine.hz(table.remove(notes,1))
```

this simpler line just gets the first element of the table and removes it, so the notes get played in order.

try changing the strum speed by altering:

```lua
clock.sleep(0.05)
```

and you can change how frequently the strum happens by changing this line:

```lua
clock.sleep(math.random(3,9))
```

as is, the strum will happen randomly every 3-9 seconds.

### sequence weirder

the sequencer step values can be used for any number of things. instead of modulating the loop time, let's modulate the delay rate, which will re-pitch the delay line wildly.

see line 52:

```lua
softcut.loop_end(1,numbers[pos]/8)
```

<dl>
  <dt><b>numbers</b></dt>
  <dd>a table (line 25) that gets updated with the knob interface. it's the sequencer data, which is basically up to 16 steps of values 1-8</dd>
  <dt><b>pos</b></dt>
  <dd>the playback position. line 50 advances the position by adding 1 and maybe wrapping back to the start. (hint: try changing <i>pos+1</i> to <i>pos-1</i> to make it run backwards!)</dd>
  <dt><b>loop_end</b></dt>
  <dd> we're dividing the step value by 8, so we'll set <i>loop_end</i> setting to between 1/8 and 1.0 (= 8/8)</dd>
</dl>

let's comment out this line and modulate `rate` instead:

```lua
--softcut.loop_end(1,numbers[pos]/8)
softcut.rate(1,numbers[pos]/8)
```

save and try! since the rate jumps are very large the result is substantial. let's try making it more subtle:

```lua
softcut.rate(1,1+(numbers[pos]/64))
```

this confines the numbers to a smaller range for a subtler effect. or perhaps we'd like to try something with multiples:

```lua
rates = {-1.0,-0.5,0.25,0.5,1.0,1.5,2.0,3.0}
softcut.rate(1,rates[numbers[pos]])
```

we've made a table `rates` which has 8 elements, letting us map the range of each step. this set of numbers contains a bunch of octaves which can create sparkly-delays. it also contains negative numbers which make for some nice reversals.

try setting `softcut.rate_slew_time(1,0)` down around line 98, which will make rate changes instantaneous rather than sliding.

## from here

suggested exercises:

- have the sequencer play notes using `engine.hz()`
- create a table to specify which frequencies get played. consider [just intonation](https://en.wikipedia.org/wiki/Just_intonation)
- randomize `x` for `engine.pw(x)` on each sequencer step
- have K2 toggle delay feedback (`pre_level`) between `0.8` and `1.0` 
- have K3 cycle delay speed with a table `{-1.0,0.5,1.0}`

and then on to [study 1: many tomorrows](../study-1) for a more in-depth scripting journey.

## resources

- [script reference](../reference) - list of commands and how to use them
- [first light walkthrough](https://vimeo.com/515473339) - a recorded livestream of dan derks doing a norns study 0 walkthrough
